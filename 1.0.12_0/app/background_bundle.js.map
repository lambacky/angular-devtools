{
  "version": 3,
  "sources": ["../../../../../../../../devtools/projects/shell-browser/src/app/tab_manager.ts", "../../../../../../../../devtools/projects/shell-browser/src/app/background.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/// <reference types=\"chrome\"/>\n\nimport {Events, Topic} from 'protocol';\n\nexport interface ContentScriptConnection {\n  port: chrome.runtime.Port | null;\n  enabled: boolean;\n  frameId: 'devtools' | number;\n  backendReady?: Promise<void>;\n}\n\nexport interface DevToolsConnection {\n  devtools: chrome.runtime.Port | null;\n  contentScripts: {[name: string]: ContentScriptConnection};\n}\n\nfunction isNumeric(str: string): boolean {\n  return +str + '' === str;\n}\n\nexport interface Tabs {\n  [tabId: string]: DevToolsConnection | undefined;\n}\n\nexport class TabManager {\n  constructor(\n    private tabs: Tabs,\n    private runtime: typeof chrome.runtime,\n  ) {}\n\n  static initialize(tabs: Tabs, runtime: typeof chrome.runtime = chrome.runtime): TabManager {\n    const manager = new TabManager(tabs, runtime);\n    manager.initialize();\n    return manager;\n  }\n\n  private initialize(): void {\n    this.runtime.onConnect.addListener((port) => {\n      if (isNumeric(port.name)) {\n        this.registerDevToolsForTab(port);\n        return;\n      }\n\n      if (\n        !port.sender ||\n        !port.sender.tab ||\n        port.sender.tab.id === undefined ||\n        port.sender.frameId === undefined\n      ) {\n        console.warn('Received a connection from an unknown sender', port);\n        return;\n      }\n\n      this.registerContentScriptForTab(port);\n    });\n  }\n\n  private ensureTabExists(tabId: number): void {\n    this.tabs[tabId] ??= {\n      devtools: null,\n      contentScripts: {},\n    };\n  }\n\n  private registerDevToolsForTab(port: chrome.runtime.Port): void {\n    // For the devtools page, our port name is the tab id.\n    const tabId = parseInt(port.name, 10);\n\n    this.ensureTabExists(tabId);\n    const tab = this.tabs[tabId]!;\n\n    tab.devtools = port;\n    tab.devtools.onDisconnect.addListener(() => {\n      tab.devtools = null;\n\n      for (const connection of Object.values(tab.contentScripts)) {\n        connection.enabled = false;\n      }\n    });\n\n    // DevTools may register after the content script has already registered. If that's the case,\n    // we need to set up the double pipe between the devtools and each content script, and send\n    // the contentScriptConnected message to the devtools page to inform it of all frames on the page.\n    for (const [frameId, connection] of Object.entries(tab.contentScripts)) {\n      connection.backendReady!.then(() => {\n        if (connection.port === null) {\n          throw new Error(\n            'Expected Content to have already connected before the backendReady event on the same page.',\n          );\n        }\n        this.doublePipe(tab.devtools, connection);\n        tab.devtools!.postMessage({\n          topic: 'contentScriptConnected',\n          args: [parseInt(frameId, 10), connection.port.name, connection.port.sender!.url],\n        });\n      });\n    }\n  }\n\n  private registerContentScriptForTab(port: chrome.runtime.Port): void {\n    // A content script connection will have a sender and a tab id.\n    const sender = port.sender!;\n    const frameId = sender.frameId!;\n    const tabId = sender.tab!.id!;\n\n    this.ensureTabExists(tabId);\n    const tab = this.tabs[tabId]!;\n\n    if (tab.contentScripts[frameId] === undefined) {\n      tab.contentScripts[frameId] = {\n        port: null,\n        enabled: false,\n        frameId: -1,\n      };\n    }\n\n    const contentScript = tab.contentScripts[frameId]!;\n    contentScript.port = port;\n    contentScript.frameId = frameId;\n    contentScript.enabled = contentScript.enabled ?? false;\n\n    // When the content script disconnects, clean up the connection state we're storing in the\n    // background page.\n    port.onDisconnect.addListener(() => {\n      delete tab.contentScripts[frameId];\n\n      if (Object.keys(tab.contentScripts).length === 0) {\n        delete this.tabs[tabId];\n      }\n    });\n\n    contentScript.backendReady = new Promise((resolveBackendReady) => {\n      const onBackendReady = (message: {topic: string}) => {\n        if (message.topic === 'backendReady') {\n          // If DevTools is not yet connected, this resolve will enable devtools to eventually connect to this\n          // content script (even though the content script connected first)\n          resolveBackendReady();\n\n          // If the devtools connection is already established, set up the double pipe between the\n          // devtools and the content script.\n          if (tab.devtools) {\n            this.doublePipe(tab.devtools, contentScript);\n\n            tab.devtools.postMessage({\n              topic: 'contentScriptConnected',\n              args: [frameId, contentScript.port!.name, contentScript.port!.sender!.url],\n            });\n          }\n\n          port.onMessage.removeListener(onBackendReady);\n        }\n      };\n\n      port.onMessage.addListener(onBackendReady);\n      port.onDisconnect.addListener(() => {\n        port.onMessage.removeListener(onBackendReady);\n      });\n    });\n  }\n\n  private doublePipe(\n    devtoolsPort: chrome.runtime.Port | null,\n    contentScriptConnection: ContentScriptConnection,\n  ): void {\n    if (devtoolsPort === null) {\n      throw new Error('DevTools port is equal to null');\n    }\n\n    const contentScriptPort = contentScriptConnection.port;\n\n    if (contentScriptPort === null) {\n      throw new Error('Content script port is equal to null');\n    }\n\n    // tslint:disable-next-line:no-console\n    console.log('Creating two-way communication channel', Date.now(), this.tabs);\n\n    const onDevToolsMessage = (message: {topic: Topic; args: Parameters<Events[Topic]>}) => {\n      if (message.topic === 'enableFrameConnection') {\n        if (message.args.length !== 2) {\n          throw new Error('Expected two arguments for enableFrameConnection');\n        }\n\n        const [frameId, tabId] = message.args as [frameId: number, tabId: number];\n\n        if (frameId === contentScriptConnection.frameId) {\n          const tab = this.tabs[tabId];\n\n          if (tab === undefined) {\n            throw new Error(`Expected tab to be registered with tabId ${tabId}`);\n          }\n\n          for (const frameId of Object.keys(tab.contentScripts)) {\n            tab.contentScripts[frameId].enabled = false;\n          }\n\n          contentScriptConnection.enabled = true;\n          devtoolsPort.postMessage({\n            topic: 'frameConnected',\n            args: [contentScriptConnection.frameId],\n          });\n        }\n      }\n\n      // Do not allow any message to be sent if a content script is not enabled. This is the\n      // mechanism that lets us select which content script connection Angular Devtools is connected\n      // to.\n      if (!contentScriptConnection.enabled) {\n        return;\n      }\n\n      contentScriptPort.postMessage(message);\n    };\n    devtoolsPort.onMessage.addListener(onDevToolsMessage);\n\n    const onContentScriptMessage = (message: {topic: Topic; args: Parameters<Events[Topic]>}) => {\n      // Do not allow any message to be sent if a content script is not enabled. This is the\n      // mechanism that lets us select which content script connection Angular Devtools is connected\n      // to.\n      if (!contentScriptConnection.enabled) {\n        return;\n      }\n\n      devtoolsPort.postMessage(message);\n    };\n    contentScriptPort.onMessage.addListener(onContentScriptMessage);\n\n    const shutdownContentScript = () => {\n      devtoolsPort.onMessage.removeListener(onDevToolsMessage);\n      devtoolsPort.postMessage({\n        topic: 'contentScriptDisconnected',\n        args: [contentScriptConnection.frameId, contentScriptConnection.port!.name],\n      });\n\n      contentScriptPort.onMessage.removeListener(onContentScriptMessage);\n    };\n    contentScriptPort.onDisconnect.addListener(() => shutdownContentScript());\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/// <reference types=\"chrome\"/>\n\nimport {AngularDetection} from 'protocol';\nimport {TabManager, Tabs} from './tab_manager';\n\nfunction getPopUpName(ng: AngularDetection): string {\n  if (!ng.isAngular) {\n    return 'not-angular.html';\n  }\n  if (!ng.isIvy || !ng.isSupportedAngularVersion) {\n    return 'unsupported.html';\n  }\n  if (!ng.isDebugMode) {\n    return 'production.html';\n  }\n  return 'supported.html';\n}\n\nif (chrome !== undefined && chrome.runtime !== undefined) {\n  const isManifestV3 = chrome.runtime.getManifest().manifest_version === 3;\n\n  const browserAction = (() => {\n    // Electron does not expose browserAction object,\n    // Use empty calls as fallback if they are not defined.\n    const noopAction = {setIcon: () => {}, setPopup: () => {}};\n\n    if (isManifestV3) {\n      return chrome.action || noopAction;\n    }\n\n    return chrome.browserAction || noopAction;\n  })();\n\n  // By default use the black and white icon.\n  // Replace it only when we detect an Angular app.\n  browserAction.setIcon(\n    {\n      path: {\n        16: chrome.runtime.getURL(`assets/icon-bw16.png`),\n        48: chrome.runtime.getURL(`assets/icon-bw48.png`),\n        128: chrome.runtime.getURL(`assets/icon-bw128.png`),\n      },\n    },\n    () => {},\n  );\n\n  chrome.runtime.onMessage.addListener((req: AngularDetection, sender) => {\n    if (!req.isAngularDevTools) {\n      return;\n    }\n\n    if (sender && sender.tab) {\n      browserAction.setPopup({\n        tabId: sender.tab.id,\n        popup: `popups/${getPopUpName(req)}`,\n      });\n    }\n\n    if (sender && sender.tab && req.isAngular) {\n      browserAction.setIcon(\n        {\n          tabId: sender.tab.id,\n          path: {\n            16: chrome.runtime.getURL(`assets/icon16.png`),\n            48: chrome.runtime.getURL(`assets/icon48.png`),\n            128: chrome.runtime.getURL(`assets/icon128.png`),\n          },\n        },\n        () => {},\n      );\n    }\n  });\n\n  const tabs = {};\n  TabManager.initialize(tabs);\n}\n"],
  "mappings": "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",
  "names": ["isNumeric", "str", "TabManager", "tabs", "runtime", "constructor", "initialize", "chrome", "manager", "onConnect", "addListener", "port", "name", "registerDevToolsForTab", "sender", "tab", "id", "undefined", "frameId", "console", "warn", "registerContentScriptForTab", "ensureTabExists", "tabId", "devtools", "contentScripts", "parseInt", "onDisconnect", "connection", "Object", "values", "enabled", "entries", "backendReady", "then", "Error", "doublePipe", "postMessage", "topic", "args", "url", "contentScript", "keys", "length", "Promise", "resolveBackendReady", "onBackendReady", "message", "onMessage", "removeListener", "devtoolsPort", "contentScriptConnection", "contentScriptPort", "log", "Date", "now", "onDevToolsMessage", "onContentScriptMessage", "shutdownContentScript", "getPopUpName", "ng", "isAngular", "isIvy", "isSupportedAngularVersion", "isDebugMode", "chrome", "undefined", "runtime", "isManifestV3", "getManifest", "manifest_version", "browserAction", "noopAction", "setIcon", "setPopup", "action", "path", "getURL", "onMessage", "addListener", "req", "sender", "isAngularDevTools", "tab", "tabId", "id", "popup", "tabs", "TabManager", "initialize"]
}
